--- SDL-1.2.5.orig/configure.in	Mon Oct  7 05:34:53 2002
+++ SDL-1.2.5/configure.in	Fri Jan 31 20:32:11 2003
@@ -1460,8 +1460,13 @@
         if test x$video_qtopia = xyes; then
             CFLAGS="$CFLAGS -DENABLE_QTOPIA -DQT_QWS_EBX -DQT_QWS_CUSTOM -DQWS -I${QPEDIR}/include -I${QTDIR}/include/ -DNO_DEBUG -fno-rtti -fno-exceptions"
             SDL_LIBS="$SDL_LIBS -L${QPEDIR}/lib -L${QTDIR}/lib/ -lqpe -lqte"
+            SDL_CFLAGS="$SDL_CFLAGS -DQWS"
             VIDEO_SUBDIRS="$VIDEO_SUBDIRS qtopia"
             VIDEO_DRIVERS="$VIDEO_DRIVERS qtopia/libvideo_qtopia.la"
+	else
+	    AC_MSG_ERROR([
+*** Failed to find Qtopia includes. Make sure that the QTDIR and QPEDIR
+*** environment variables are set correctly.])
         fi
         AC_LANG_C
     fi
--- SDL-1.2.5.orig/src/audio/dsp/SDL_dspaudio.c	Mon Apr 15 16:38:54 2002
+++ SDL-1.2.5/src/audio/dsp/SDL_dspaudio.c	Fri Jul  4 05:56:01 2003
@@ -263,7 +263,34 @@
 		SDL_SetError("Fragment size must be a power of two");
 		return(-1);
 	}
-	frag_spec |= 0x00020000;	/* two fragments, for low latency */
+
+    {
+        // workaround for SL series
+        int nfragments = 2;
+        char buf[FILENAME_MAX];
+        FILE *fp;
+        const char *env;
+
+        fp = fopen("/proc/deviceinfo/product", "rb");
+        if (fp) {
+            fread(buf, 1, 7, fp);
+            fclose(fp);
+            if (strncmp(buf, "SL-A300", 7) == 0)
+                nfragments = 18;
+        }
+
+
+        env = getenv("SDL_DSP_NFRAGMENTS");
+        if (env) {
+            nfragments = atoi(env);
+            if (nfragments < 2)
+                nfragments = 2;
+            else if (nfragments > 31)
+                nfragments = 31;
+        }
+
+        frag_spec |= (nfragments << 16);
+    }
 
 	/* Set the audio buffering parameters */
 #ifdef DEBUG_AUDIO
--- SDL-1.2.5.orig/src/video/SDL_video.c	Sun Oct  6 01:50:56 2002
+++ SDL-1.2.5/src/video/SDL_video.c	Thu Jan  2 16:20:18 2003
@@ -54,6 +54,9 @@
 #ifdef ENABLE_NANOX
 	&NX_bootstrap,
 #endif
+#ifdef ENABLE_QTOPIA
+	&Qtopia_bootstrap,
+#endif
 #ifdef ENABLE_FBCON
 	&FBCON_bootstrap,
 #endif
@@ -110,9 +113,6 @@
 #endif
 #ifdef ENABLE_GEM
 	&GEM_bootstrap,
-#endif
-#ifdef ENABLE_QTOPIA
-	&Qtopia_bootstrap,
 #endif
 #ifdef ENABLE_PICOGUI
 	&PG_bootstrap,
--- SDL-1.2.5.orig/src/video/qtopia/SDL_QWin.cc	Sun Sep  1 09:37:24 2002
+++ SDL-1.2.5/src/video/qtopia/SDL_QWin.cc	Mon Jun 23 23:46:35 2003
@@ -1,3 +1,4 @@
+/* -*- mode: c++; tab-width: 8; c-file-style: "gnu" -*- */
 /*
     SDL - Simple DirectMedia Layer
     Copyright (C) 1997, 1998, 1999, 2000, 2001  Sam Lantinga
@@ -27,6 +28,7 @@
 
 #include "SDL_QWin.h"
 #include <qapplication.h>
+#include <qpe/qpeapplication.h>
 #include <qdirectpainter_qws.h>
 
 screenRotationT screenRotation = SDL_QT_NO_ROTATION;
@@ -34,8 +36,11 @@
 SDL_QWin::SDL_QWin(const QSize& size)
   : QWidget(0, "SDL_main"), my_painter(0), my_image(0),
     my_inhibit_resize(false), my_mouse_pos(-1,-1), my_flags(0),
-    my_has_fullscreen(false), my_locked(0)
+    my_has_fullscreen(false), my_locked(0),
+    rotation_(0), qteRotation_(0), keyRotation_(0), qteKeyRotation_(0),
+    isSLA300InputFix_(0)
 {
+  for (int i = 0; i < 5; i++) curAxis_[i] = 0;
   setBackgroundMode(NoBackground);
 }
 
@@ -84,6 +89,7 @@
 }
 
 void SDL_QWin::setMousePos(const QPoint &pos) {
+#if 0
   if(my_image->width() == height()) {
     if (screenRotation == SDL_QT_ROTATION_90)
       my_mouse_pos = QPoint(height()-pos.y(), pos.x());
@@ -92,6 +98,55 @@
   } else {
     my_mouse_pos = pos;
   }
+#else
+  QPoint realPos;
+  switch (qteRotation_) {
+  case 0:
+    realPos = pos;
+    break;
+  case 1:
+    realPos.setX(pos.y());
+    realPos.setY(fbSize_.height() - 1 - pos.x());
+    break;
+  case 2:
+    realPos.setX(fbSize_.width() - 1 - pos.x());
+    realPos.setY(fbSize_.height() - 1 - pos.y());
+    break;
+  case 3:
+    realPos.setX(fbSize_.width() - 1 - pos.y());
+    realPos.setY(pos.x());
+    break;
+  };
+
+//   fprintf(stderr, "setMousePos: realPos(%d, %d)\n", realPos.x(), realPos.y());
+
+  int borderWidth = (fbSize_.width() - my_image->width()) >> 1;
+  int borderHeight = (fbSize_.height() - my_image->height()) >> 1;
+  if ( rotation_ & 1 ){
+    borderWidth = (fbSize_.height() - my_image->width()) >> 1;
+    borderHeight = (fbSize_.width() - my_image->height()) >> 1;
+  }
+  realPos.setX(realPos.x() - borderWidth);
+  realPos.setY(realPos.y() - borderHeight);
+
+  switch (rotation_) {
+  case 0:
+    my_mouse_pos = realPos;
+    break;
+  case 1:
+    my_mouse_pos.setX(realPos.y());
+    my_mouse_pos.setY(my_image->height() - 1 - realPos.x());
+    break;
+  case 2:
+    my_mouse_pos.setX(my_image->width() - 1 - realPos.x());
+    my_mouse_pos.setY(my_image->height() - 1 - realPos.y());
+    break;
+  case 3:
+    my_mouse_pos.setX(realPos.y());//my_image->width() - 1 - realPos.y());
+    my_mouse_pos.setY(my_image->height() - realPos.x());
+    break;
+  }
+#endif
 }
 
 void SDL_QWin::mouseMoveEvent(QMouseEvent *e) {
@@ -129,149 +184,306 @@
   my_mouse_pos = QPoint(-1, -1);
 }
 
-#define USE_DIRECTPAINTER
+#ifndef __i386__
 
+static void
+blitRotate3(Uint16 *dstBits, const QSize& dstSize,
+            const Uint16 *srcBits, const QSize& srcSize,
+            const QRect& srcBlitRect);
+
+static void
+blitRotate0(Uint16 *dstBits, const QSize& dstSize,
+            const Uint16 *srcBits, const QSize& srcSize,
+            const QRect& srcBlitRect)
+{
+  srcBits += srcBlitRect.left() + srcBlitRect.top() * srcSize.width();
+  dstBits += ((dstSize.width() - srcSize.width()) >> 1)
+    + (((dstSize.height() - srcSize.height()) >> 1) * dstSize.width());
+  dstBits += srcBlitRect.left() + srcBlitRect.top() * dstSize.width();
+  int w = srcBlitRect.width() << 1;
+  int h = srcBlitRect.height();
+
+  while (h--) {
+    memcpy(dstBits, srcBits, w);
+    dstBits += dstSize.width();
+    srcBits += srcSize.width();
+  }
+}
 
-#ifndef __i386__
-static inline void gs_fastRotateBlit_3 ( unsigned short *fb,
-					 unsigned short *bits,
-					 const QRect& rect )
+static void
+blitRotate1(Uint16 *dstBits, const QSize& dstSize,
+            const Uint16 *srcBits, const QSize& srcSize,
+            const QRect& srcBlitRect)
 {
-  int startx, starty;
-  int width, height;
-  
-  startx = rect.left() >> 1;
-  starty = rect.top() >> 1;
-  width  = ((rect.right() - rect.left()) >> 1) + 2;
-  height = ((rect.bottom() - rect.top()) >> 1) + 2;
-
-  if((startx+width) > 120) {
-    width = 120 - startx; // avoid horizontal overflow
-  }
-  if((starty+height) > 160) { 
-    height = 160 - starty; // avoid vertical overflow
-  }
-
-  ulong *sp1, *sp2, *dp1, *dp2;
-  ulong stop, sbot, dtop, dbot;    
-  
-  sp1 = (ulong*)bits + startx + starty*240;
-  sp2 = sp1 + 120;
-  dp1 = (ulong *)fb + (159 - starty) + startx*320;
-  dp2 = dp1 + 160;
-  int rowadd = (-320*width) - 1;
-  int rowadd2 = 240 - width;
-  // transfer in cells of 2x2 pixels in words
-  for (int y=0; y<height; y++) {
-    for (int x=0; x<width; x++) {
-      // read source pixels
-      stop = *sp1;
-      sbot = *sp2;
-      // rotate pixels
-      dtop = (sbot & 0xffff) + ((stop & 0xffff)<<16);
-      dbot = ((sbot & 0xffff0000)>>16) + (stop & 0xffff0000);
-      // write to framebuffer
-      *dp1 = dtop;
-      *dp2 = dbot;
-      // update source ptrs
-      sp1++; sp2++;
-      // update dest ptrs - 2 pix at a time
-      dp1 += 320;
-      dp2 += 320;
+//   fprintf(stdout, "SDL_QT_ROTATION (1) is not implemented.\n");
+  blitRotate3(dstBits, dstSize, srcBits, srcSize, srcBlitRect);
+}
+
+static void
+blitRotate2(Uint16 *dstBits, const QSize& dstSize,
+            const Uint16 *srcBits, const QSize& srcSize,
+            QRect srcBlitRect)
+{
+//   if (srcBlitRect.left() & 1)
+//     srcBlitRect.setLeft(srcBlitRect.left() - 1);
+//   if (srcBlitRect.right() & 1)
+//     srcBlitRect.setRight(srcBlitRect.right() - 1);
+
+  int dstBorderLeftRight = (dstSize.width() - srcSize.width()) >>1;
+  int dstBorderTopBottom = (dstSize.height() - srcSize.height()) >>1;
+  int dstStartOffsetX = dstSize.width() - dstBorderLeftRight - 2;
+  int dstStartOffsetY = dstSize.height() - dstBorderTopBottom - 1;
+  int left = srcBlitRect.left() & ~(int)1; // to be 32bit aligned
+  srcBits += left + srcBlitRect.top() * srcSize.width();
+  dstBits += dstStartOffsetY * dstSize.width() + dstStartOffsetX;
+  dstBits -= left;
+  dstBits -= srcBlitRect.top() * dstSize.width();
+
+  Uint32 *pSrc = (Uint32 *)srcBits;
+  Uint32 *pDst = (Uint32 *)dstBits;
+
+  int width = srcBlitRect.width(), width2 = srcBlitRect.width(), w;
+  if ( srcBlitRect.left() & 1 ){
+    width--; width2++;
+  }
+  if ( (srcBlitRect.left()+srcBlitRect.width()) & 1 ){
+    width--; width2++;
+  }
+  width >>= 1;
+  int height = srcBlitRect.height();
+  int srcYAdd = srcSize.width() - width2;
+  int dstYSub = dstSize.width() - width2;
+
+  while (height--) {
+    w = width;
+    if (srcBlitRect.left() & 1){
+      *((Uint16 *)pDst) = *(((Uint16 *)pSrc) + 1);
+      pDst--; pSrc++;
+    }
+    while (w--) {
+      *pDst-- = (*pSrc << 16) | (*pSrc >> 16);
+      ++pSrc;
     }
-    // adjust src ptrs - skip a row as we work in pairs
-    sp1 += rowadd2;
-    sp2 += rowadd2;
-    // adjust dest ptrs for rotation
-    dp1 += rowadd;
-    dp2 += rowadd;
+    if ((srcBlitRect.left()+srcBlitRect.width()) & 1){
+      *(((Uint16 *)pDst) + 1) = *((Uint16 *)pSrc);
+      pDst--; pSrc++;
+    }
+    (Uint16 *)pSrc += srcYAdd;
+    (Uint16 *)pDst -= dstYSub;
   }
 }
+
+#define BLIT_ROTATE_3_MOV32
+
+static void
+blitRotate3(Uint16 *dstBits, const QSize& dstSize,
+            const Uint16 *srcBits, const QSize& srcSize,
+            const QRect& srcBlitRect)
+{
+  if (srcBlitRect.width() != dstSize.height() ||
+      srcBlitRect.height() != dstSize.width()) {
+    // partial update
+    const Uint16 *pSrc = srcBits +
+      (srcBlitRect.left() + srcBlitRect.top() * srcSize.width());
+
+    int dstBorderLeftRight = (dstSize.width() - srcSize.height()) >>1;
+    int dstBorderTopBottom = (dstSize.height() - srcSize.width()) >>1;
+    int dstStartOffsetX = dstSize.width() - dstBorderLeftRight - 1;
+    int dstStartOffsetY = dstBorderTopBottom;
+    Uint16 *pDst = dstBits +
+      (dstStartOffsetY * dstSize.width() + dstStartOffsetX);
+    pDst += srcBlitRect.left() * dstSize.width();
+    pDst -= srcBlitRect.top();
+
+    int width = srcBlitRect.width(), height = srcBlitRect.height(), w;
+    int srcYAdd = srcSize.width() - srcBlitRect.width();
+    int dstXAdd = dstSize.width();
+    int dstYSub = (dstSize.width() * srcBlitRect.width()) + 1;
+
+#if 0
+    fprintf(stderr, "---- Blit begin\n");
+    fprintf(stderr, "srcSize.width: %d srcSize.height:%d\n",
+            srcSize.width(), srcSize.height());
+    fprintf(stderr, "srcBlitRect.left:%d srcBlitRect.right:%d srcBlitRect.top:%d srcBlitRect.bottom:%d srcBlitRect.width:%d srcBlitRect.height:%d\n",
+            srcBlitRect.left(), srcBlitRect.right(), srcBlitRect.top(), srcBlitRect.bottom(), srcBlitRect.width(), srcBlitRect.height());
+
+    fprintf(stderr, "dstSize.width: %d dstSize.height:%d\n",
+            dstSize.width(), dstSize.height());
+    fprintf(stderr, "dstBorderLeftRight:%d dstBorderTopBottom:%d dstStartOffsetX:%d dstStartOffsetY:%d\n",
+            dstBorderLeftRight, dstBorderTopBottom, dstStartOffsetX, dstStartOffsetY);
+    fprintf(stderr, "srcYAdd:%d dstXAdd:%d dstYSub:%d\n", srcYAdd, dstXAdd, dstYSub);
 #endif
 
+    while (height--) {
+      w = width;
+      while (w--) {
+        *pDst = *pSrc ++;
+        pDst += dstXAdd;
+      }
+      pSrc += srcYAdd;
+      pDst -= dstYSub;
+    }
+    // 		fprintf(stderr, "---- Blit end\n");
+  } else {
+    // full update
+#if !defined(BLIT_ROTATE_3_MOV32)
+    const Uint16 *src = srcBits;
+    Uint16 *dst = dstBits + (dstSize.width() - 1);
+    int w = srcBlitRect.width();
+    int h = srcBlitRect.height();
+    int i, dstSub = dstSize.width() * w + 1;
+    int dstAdd = dstSize.width();
+
+    while (h--) {
+      i = w;
+      while (i--) {
+        *dst = *src ++;
+        dst += dstAdd;
+      }
+      dst -= dstSub;
+    }
+#else  // BLIT_ROTATE_3_MOV32
+    Uint32 *src1 = (Uint32 *)(srcBits);
+    Uint32 *src2 = (Uint32 *)(srcBits + srcSize.width());
+    Uint32 *dst1 = (Uint32 *)(dstBits + (dstSize.width() - 2));
+    Uint32 *dst2 = (Uint32 *)(dstBits + (dstSize.width() + dstSize.width() - 2));
+    int w = srcBlitRect.width() >> 3;
+    int h = srcBlitRect.height() >> 1;
+    int i, dstSub = ((dstSize.width() * srcBlitRect.width()) >> 1) + 1;
+    int dstAdd = dstSize.width();
+
+    Uint32 a, b;
+    while (h--) {
+      i = w;
+      while (i--) {
+        a = *src1 ++;
+        b = *src2 ++;
+        *dst1 = (a << 16) | (b & 0xFFFF);
+        *dst2 = (a & 0xFFFF0000) | (b >> 16);
+        dst1 += dstAdd;
+        dst2 += dstAdd;
+
+        a = *src1 ++;
+        b = *src2 ++;
+        *dst1 = (a << 16) | (b & 0xFFFF);
+        *dst2 = (a & 0xFFFF0000) | (b >> 16);
+        dst1 += dstAdd;
+        dst2 += dstAdd;
+
+        a = *src1 ++;
+        b = *src2 ++;
+        *dst1 = (a << 16) | (b & 0xFFFF);
+        *dst2 = (a & 0xFFFF0000) | (b >> 16);
+        dst1 += dstAdd;
+        dst2 += dstAdd;
+
+        a = *src1 ++;
+        b = *src2 ++;
+        *dst1 = (a << 16) | (b & 0xFFFF);
+        *dst2 = (a & 0xFFFF0000) | (b >> 16);
+        dst1 += dstAdd;
+        dst2 += dstAdd;
+      }
+      src1 += srcSize.width() >> 1;
+      src2 += srcSize.width() >> 1;
+      dst1 -= dstSub;
+      dst2 -= dstSub;
+    }
+#endif // BLIT_ROTATE_3_MOV32
+  }
+}
+
+#endif // __i386__
+
 void SDL_QWin::repaintRect(const QRect& rect) {
   if(!my_painter || !rect.width() || !rect.height()) {
     return;
   }
 #ifndef __i386__
-
-  if(QPixmap::defaultDepth() == 16 &&
-     my_painter->transformOrientation() == 3 &&
-     my_painter->numRects() >= 0) {
-    if(my_image->width() == width()) {
-      ushort *fb = (ushort*)my_painter->frameBuffer();
-      ushort *buf = (ushort*)my_image->bits();
-      gs_fastRotateBlit_3(fb, buf, rect);
-    } else {
-      // landscape mode
-      if (screenRotation == SDL_QT_ROTATION_90) {
-        uchar *fb = (uchar*)my_painter->frameBuffer();
-        uchar *buf = (uchar*)my_image->bits();
-        if(rect == my_image->rect()) {
-          memcpy(fb, buf, width()*height()*2);
-        } else {
-          int h = rect.height();
-          int wd = rect.width()<<1;
-          int fblineadd = my_painter->lineStep();
-          int buflineadd = my_image->bytesPerLine();
-          fb  += (rect.left()<<1) + rect.top() * my_painter->lineStep();
-          buf += (rect.left()<<1) + rect.top() * my_image->bytesPerLine();
-          while(h--) {
-            memcpy(fb, buf, wd);
-            fb += fblineadd;
-            buf += buflineadd;
-          }
-        }
-      }
-      else if (screenRotation == SDL_QT_ROTATION_270) {
-        int h = rect.height();
-        int wd = rect.width();
-        int fblineadd = my_painter->lineStep() - (rect.width() << 1);
-        int buflineadd = my_image->bytesPerLine() - (rect.width() << 1);
-        int w;
-
-        uchar *fb = (uchar*)my_painter->frameBuffer();
-        uchar *buf = (uchar*)my_image->bits();
-        
-        fb += ((my_painter->width() - (rect.top() + rect.height())) * 
-            my_painter->lineStep()) + ((my_painter->height() - ((rect.left() + 
-                                                                 rect.width()))) << 1);
-
-        buf += my_image->bytesPerLine() * (rect.top() + rect.height()) -
-            (((my_image->width() - (rect.left() + rect.width())) << 1) + 2);
-
-        while(h--) {
-          w = wd;
-          while(w--) *((unsigned short*)fb)++ = *((unsigned short*)buf)--;
-          fb += fblineadd;
-          buf -= buflineadd;
-          }
-        }
+  if (QPixmap::defaultDepth() == 16 && my_painter->numRects() >= 0) {
+    Uint16 *fb = (Uint16*)my_painter->frameBuffer();
+    Uint16 *buf = (Uint16*)my_image->bits();
+    switch (rotation_) {
+    case 0:
+      blitRotate0(fb, fbSize_,
+                  buf, QSize(my_image->width(), my_image->height()),
+                  rect);
+      break;
+    case 1:
+      blitRotate1(fb, fbSize_,
+                  buf, QSize(my_image->width(), my_image->height()),
+                  rect);
+      break;
+    case 2:
+      blitRotate2(fb, fbSize_,
+                  buf, QSize(my_image->width(), my_image->height()),
+                  rect);
+      break;
+    case 3:
+      blitRotate3(fb, fbSize_,
+                  buf, QSize(my_image->width(), my_image->height()),
+                  rect);
+      break;
     }
   } else {
-#endif
-    QPainter pp(this);
+#endif // __i386__
+    QDirectPainter pp(this);
     pp.drawImage(rect.topLeft(), *my_image, rect);
-    pp.end();
+//     pp.end();
 #ifndef __i386__
   }
-#endif
+#endif // __i386__
 }
 
 // This paints the current buffer to the screen, when desired. 
 void SDL_QWin::paintEvent(QPaintEvent *ev) {  
   if(my_image && isVisible() && isActiveWindow()) {
-    lockScreen();
+    // TODO: better handling
+    lockScreen(true);
     repaintRect(ev->rect());
     unlockScreen();
   }
 }  
 
-/* Function to translate a keyboard transition and queue the key event */
+int SDL_QWin::ApplyKeyRotation(int key)
+{
+  int c;
+  int sdlScancode[] = { SDLK_LEFT, SDLK_DOWN, SDLK_RIGHT, SDLK_UP };
+
+  switch (key) {
+  case Qt::Key_Left:
+    c = 0;
+    break;
+  case Qt::Key_Down:
+    c = 1;
+    break;
+  case Qt::Key_Right:
+    c = 2;
+    break;
+  case Qt::Key_Up:
+    c = 3;
+    break;
+  default:
+    return 0;
+  }
+
+//   c = (c + qteKeyRotation_) & 3;
+//   return sdlScancode[(c - keyRotation_) & 3];
+  return sdlScancode[(c + qteKeyRotation_ - keyRotation_) & 3];
+}
+
+/* Function to translate a keyboard transition and queue the key event
+ * This should probably be a table although this method isn't exactly
+ * slow.
+ */
 void SDL_QWin::QueueKey(QKeyEvent *e, int pressed)
-{  
+{
+  if (e->isAutoRepeat())
+    return;
+
   SDL_keysym keysym;
   int scancode = e->key();
+
   /* Set the keysym information */
   if(scancode >= 'A' && scancode <= 'Z') {
     // Qt sends uppercase, SDL wants lowercase
@@ -292,26 +504,12 @@
     case Qt::Key_Home: scancode = SDLK_HOME; break;
     case Qt::Key_End: scancode = SDLK_END; break;
     // We want the control keys to rotate with the screen
-    case Qt::Key_Left: 
-        if (screenRotation == SDL_QT_ROTATION_90) scancode = SDLK_UP;
-        else if (screenRotation == SDL_QT_ROTATION_270) scancode = SDLK_DOWN;
-        else scancode = SDLK_LEFT;
-        break;
-    case Qt::Key_Up: 
-        if (screenRotation == SDL_QT_ROTATION_90) scancode = SDLK_RIGHT;
-        else if (screenRotation == SDL_QT_ROTATION_270) scancode = SDLK_LEFT;
-        else scancode = SDLK_UP;
-        break;
-    case Qt::Key_Right: 
-        if (screenRotation == SDL_QT_ROTATION_90) scancode = SDLK_DOWN;
-        else if (screenRotation == SDL_QT_ROTATION_270) scancode = SDLK_UP;
-        else scancode = SDLK_RIGHT;
-        break;
+    case Qt::Key_Left:
+    case Qt::Key_Up:
+    case Qt::Key_Right:
     case Qt::Key_Down:
-        if (screenRotation == SDL_QT_ROTATION_90) scancode = SDLK_LEFT;
-        else if (screenRotation == SDL_QT_ROTATION_270) scancode = SDLK_RIGHT;
-        else scancode = SDLK_DOWN;
-        break;
+      scancode = ApplyKeyRotation(scancode);
+      break;
     case Qt::Key_Prior: scancode = SDLK_PAGEUP; break;
     case Qt::Key_Next: scancode = SDLK_PAGEDOWN; break;
     case Qt::Key_Shift: scancode = SDLK_LSHIFT; break;
@@ -340,13 +538,22 @@
     case Qt::Key_Super_R: scancode = SDLK_RSUPER; break;
     case Qt::Key_Menu: scancode = SDLK_MENU; break;
     case Qt::Key_Help: scancode = SDLK_HELP; break;
+
+    case Qt::Key_F33:
+      // FIXME: This is a hack to enable the OK key on
+      // Zaurii devices. SDLK_RETURN is a suitable key to use
+      // since it often is used as such.
+      //     david@hedbor.org
+      scancode = SDLK_RETURN;
+      break;
+
     default:
       scancode = SDLK_UNKNOWN;
       break;
     }
-    keysym.sym = static_cast<SDLKey>(scancode);    
+    keysym.sym = static_cast<SDLKey>(scancode);
   } else {
-    keysym.sym = static_cast<SDLKey>(scancode);    
+    keysym.sym = static_cast<SDLKey>(scancode);
   }
   keysym.scancode = scancode;
   keysym.mod = KMOD_NONE;
@@ -366,11 +573,82 @@
   //		pressed = 1;
   //	}
 
+  if (isSLA300InputFix_ &&
+      (keysym.sym == SDLK_SPACE || (keysym.sym >= 273 && keysym.sym <= 276))) {
+      if (keysym.sym >= 273) curAxis_[keysym.sym-273] = pressed;
+      else curAxis_[4] = pressed;
+  }
+
   /* Queue the key event */
   if ( pressed ) {
-    SDL_PrivateKeyboard(SDL_PRESSED, &keysym);
+      /* fprintf(stderr, "press %d\n", keysym.sym); */
+      SDL_PrivateKeyboard(SDL_PRESSED, &keysym);
+      if (isSLA300InputFix_ &&
+          (keysym.sym >= 273 && keysym.sym <= 276)) {
+          if (keysym.sym == SDLK_UP) {
+              if (curAxis_[1]) {
+                  keysym.sym = SDLK_DOWN;
+                  keysym.scancode = Qt::Key_Down;
+                  curAxis_[1] = 0;
+                  /* fprintf(stderr, "force release %d\n", keysym.sym); */
+                  SDL_PrivateKeyboard(SDL_RELEASED, &keysym);
+              }
+          }
+          else if (keysym.sym == SDLK_DOWN) {
+              if (curAxis_[0]) {
+                  keysym.sym = SDLK_UP;
+                  keysym.scancode = Qt::Key_Up;
+                  curAxis_[0] = 0;
+                  /* fprintf(stderr, "force release %d\n", keysym.sym); */
+                  SDL_PrivateKeyboard(SDL_RELEASED, &keysym);
+              }
+          }
+          else if (keysym.sym == SDLK_RIGHT) {
+              if (curAxis_[3]) {
+                  keysym.sym = SDLK_LEFT;
+                  keysym.scancode = Qt::Key_Left;
+                  curAxis_[3] = 0;
+                  /* fprintf(stderr, "force release %d\n", keysym.sym); */
+                  SDL_PrivateKeyboard(SDL_RELEASED, &keysym);
+              }
+          }
+          else if (keysym.sym == SDLK_LEFT) {
+              if (curAxis_[2]) {
+                  keysym.sym = SDLK_RIGHT;
+                  keysym.scancode = Qt::Key_Right;
+                  curAxis_[2] = 0;
+                  /* fprintf(stderr, "force release %d\n", keysym.sym); */
+                  SDL_PrivateKeyboard(SDL_RELEASED, &keysym);
+              }
+          }
+      }
   } else {
-    SDL_PrivateKeyboard(SDL_RELEASED, &keysym);
+      /* fprintf(stderr, "release %d\n", keysym.sym); */
+      SDL_PrivateKeyboard(SDL_RELEASED, &keysym);
+
+      if (isSLA300InputFix_ &&
+          (keysym.sym == SDLK_SPACE ||
+           (keysym.sym >= 273 && keysym.sym <= 276))) {
+          for (int i = 0; i < 4; i++) {
+              if (curAxis_[i]) {
+                  int sym = i+273;
+                  keysym.sym = static_cast<SDLKey>(sym);
+                  if (sym == SDLK_UP) keysym.scancode = Qt::Key_Up;
+                  else if (sym == SDLK_RIGHT) keysym.scancode = Qt::Key_Right;
+                  else if (sym == SDLK_DOWN) keysym.scancode = Qt::Key_Down;
+                  else if (sym == SDLK_LEFT) keysym.scancode = Qt::Key_Left;
+                  curAxis_[i] = 0;
+                  /* fprintf(stderr, "force release %d\n", keysym.sym); */
+                  SDL_PrivateKeyboard(SDL_RELEASED, &keysym);
+              }
+          }
+          if (curAxis_[4]) {
+              keysym.scancode = keysym.sym = SDLK_SPACE;
+              curAxis_[4] = 0;
+              /* fprintf(stderr, "force release %d\n", keysym.sym); */
+              SDL_PrivateKeyboard(SDL_RELEASED, &keysym);
+          }
+      }
   }
 }
 
@@ -392,5 +670,28 @@
     // Enable fullscreen.
     showFullScreen();
     my_has_fullscreen = true;
+  }
+}
+
+bool SDL_QWin::lockScreen(bool force) {
+  if(!my_painter) {
+    if(force || (isVisible() && isActiveWindow())) {
+      my_painter = new QDirectPainter(this);
+    } else {
+      return false;
+    }
+  }
+  my_locked++; // Increate lock refcount
+  return true;
+}
+
+void SDL_QWin::unlockScreen() {
+  if(my_locked > 0) {
+    my_locked--; // decrease lock refcount;
+  }
+  if(!my_locked && my_painter) {
+//     my_painter->end();
+    delete my_painter;
+    my_painter = 0;
   }
 }
--- SDL-1.2.5.orig/src/video/qtopia/SDL_QWin.h	Sun Sep  1 09:37:24 2002
+++ SDL-1.2.5/src/video/qtopia/SDL_QWin.h	Sat Feb  1 01:12:28 2003
@@ -1,3 +1,4 @@
+/* -*- mode: c++; tab-width: 8; c-file-style: "gnu" -*- */
 /*
     SDL - Simple DirectMedia Layer
     Copyright (C) 1997, 1998, 1999, 2000, 2001  Sam Lantinga
@@ -52,6 +53,7 @@
 class SDL_QWin : public QWidget
 {
   void QueueKey(QKeyEvent *e, int pressed);
+  int SDL_QWin::ApplyKeyRotation(int key);
  public:
   SDL_QWin(const QSize& size);
   virtual ~SDL_QWin();
@@ -70,15 +72,8 @@
     x = my_offset.x();
     y = my_offset.y();
   }
-  bool beginDraw(void) {
-    return true;
-  }
-  void endDraw(void) {
-  }
-  QImage *image(void) {
-    return my_image;
-  }
-  
+  QImage *image(void) { return my_image; }
+
   void setWFlags(WFlags flags) {
     QWidget::setWFlags(flags);
     my_flags = flags;
@@ -87,23 +82,18 @@
   void setMousePos(const QPoint& newpos);
   void setFullscreen(bool);
 
-  void lockScreen() {
-    if(!my_painter) {
-      my_painter = new QDirectPainter(this);
-    }
-    my_locked++; // Increate lock refcount
-  }
-  void unlockScreen() {
-    if(my_locked > 0) {
-      my_locked--; // decrease lock refcount;
-    }
-    if(!my_locked && my_painter) {
-      my_painter->end();
-      delete my_painter;
-      my_painter = 0;
-    }
-  }
+  bool lockScreen(bool force=false);
+  void unlockScreen();
   void repaintRect(const QRect& rect);
+  void setScreenRotation(int sdlr, int qter) {
+	  rotation_ = sdlr; qteRotation_ = qter;
+  }
+  void setKeyRotation(int sdlr, int qter) {
+    keyRotation_ = sdlr; qteKeyRotation_ = qter;
+  }
+  void setFBSize(QSize& s) { fbSize_ = s; }
+//   void setSLC700InputFix(bool isEnable) { isSLC700InputFix_ = isEnable; }
+  void setSLA300InputFix(bool isEnable) { isSLA300InputFix_ = isEnable; }
  protected:
   /* Handle resizing of the window */
   virtual void resizeEvent(QResizeEvent *e);
@@ -114,12 +104,9 @@
   void mousePressEvent(QMouseEvent *e);
   void mouseReleaseEvent(QMouseEvent *e);
   void paintEvent(QPaintEvent *ev);
-  void keyPressEvent(QKeyEvent *e) {
-    QueueKey(e, 1);
-  }
-  void keyReleaseEvent(QKeyEvent *e) {
-    QueueKey(e, 0);
-  }
+  void keyPressEvent(QKeyEvent *e)   { QueueKey(e, 1); }
+  void keyReleaseEvent(QKeyEvent *e) { QueueKey(e, 0); }
+
  private:
   void enableFullscreen();
   QDirectPainter *my_painter;
@@ -130,6 +117,12 @@
   WFlags my_flags;
   WFlags my_has_fullscreen;
   unsigned int my_locked;
+  int rotation_, qteRotation_;
+  int keyRotation_, qteKeyRotation_;
+  QSize fbSize_;
+//   bool isSLC700InputFix_;
+  bool isSLA300InputFix_;
+  int curAxis_[5];   // 0: up, 1: down, 2: right, 3: left, 4: center
 };
 
 #endif /* _SDL_QWin_h */
--- SDL-1.2.5.orig/src/video/qtopia/SDL_sysmouse.cc	Mon May 20 05:06:01 2002
+++ SDL-1.2.5/src/video/qtopia/SDL_sysmouse.cc	Mon Jun 23 23:46:35 2003
@@ -60,6 +60,7 @@
 void QT_WarpWMCursor(_THIS, Uint16 x, Uint16 y)
 {
   SDL_Win->setMousePos(QPoint(x, y));
+  SDL_PrivateMouseMotion( 0, 0, x, y );
 }
 
 }; /* Extern C */
--- SDL-1.2.5.orig/src/video/qtopia/SDL_sysvideo.cc	Sun Sep  1 09:37:24 2002
+++ SDL-1.2.5/src/video/qtopia/SDL_sysvideo.cc	Mon Dec  1 06:17:30 2003
@@ -1,3 +1,4 @@
+/* -*- mode: c++; tab-width: 8; c-file-style: "gnu" -*- */
 /*
   SDL - Simple DirectMedia Layer
   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002  Sam Lantinga
@@ -29,12 +30,16 @@
 
 #include <stdlib.h>
 #include <string.h>
+#include <stdarg.h>
 
 #include <stdio.h>
 #include <unistd.h>
+#include <sys/types.h>
+#include <sys/wait.h>
 
 #include <qapplication.h>
 #include <qpe/qpeapplication.h>
+#include <qpe/qcopenvelope_qws.h>
 
 #include "SDL.h"
 #include "SDL_timer.h"
@@ -50,14 +55,67 @@
 #include "SDL_syswm_c.h"
 #include "SDL_lowvideo.h"
 
-  //#define QTOPIA_DEBUG
+  // #define QTOPIA_DEBUG
+#define QTOPIA_LOG
 #define QT_HIDDEN_SIZE	32	/* starting hidden window size */
 
+#ifdef QTOPIA_LOG
+  static FILE *st_logfp = NULL;
+#endif
+  static inline void LOG(char *fmt, ...)
+  {
+#ifdef QTOPIA_LOG
+    va_list ap;
+
+    va_start(ap, fmt);
+    vfprintf(st_logfp, fmt, ap);
+    if (st_logfp != stderr) {
+      fflush(st_logfp);
+      vfprintf(stderr, fmt, ap);
+    }
+    va_end(ap);
+#endif
+  }
+
+  typedef struct machine_spec {
+    const char *manif;
+    const char *name;
+    int qpe_server_rotation;
+    int init_screen_rot;
+    int init_key_rot;
+  } machine_spec_t;
+
+  typedef enum {
+    MACHINE_SHARP_SL5000D,
+    MACHINE_SHARP_SL5500,
+    MACHINE_SHARP_SLA300,
+    MACHINE_SHARP_SLB500,
+    MACHINE_SHARP_SLC700,
+    MACHINE_SHARP_SLC750,
+    MACHINE_SHARP_SLC760,
+    MACHINE_SHARP_SLC860,
+    MACHINE_SHARP_SL6000,
+    MACHINE_MAX
+  } machine_t;
+
+  static const machine_spec_t st_machine_spec[] = {
+    { "Sharp", "SL-5000D", 0 },
+    { "Sharp", "SL-5500", 0 },
+    { "Sharp", "SL-A300", 0 },
+    { "Sharp", "SL-B500", 0 },
+    { "Sharp", "SL-C700", 0 },
+    { "Sharp", "SL-C750", 0 },
+    { "Sharp", "SL-C760", 0 },
+    { "Sharp", "SL-C860", 0 },
+    { "Sharp", "SL-6000", 0 },
+  };
+
 /* Name of the environment variable used to invert the screen rotation or not:
    Possible values:
-   !=0 : Screen is 270° rotated
-   0: Screen is 90° rotated*/
-#define SDL_QT_ROTATION_ENV_NAME "SDL_QT_INVERT_ROTATION"
+   !=0 : Screen is 270- rotated
+   0: Screen is 90- rotated*/
+#define SDL_QT_ROTATION_ENV_NAME "SDL_QT_ROTATION"
+#define SDL_QT_INVERT_ROTATION_ENV_NAME "SDL_QT_INVERT_ROTATION"
 
   /* Initialization/Query functions */
   static int QT_VideoInit(_THIS, SDL_PixelFormat *vformat);
@@ -75,6 +133,8 @@
 
   static int QT_ToggleFullScreen(_THIS, int fullscreen);
 
+  static int QT_IconifyWindow(_THIS);
+  static SDL_GrabMode QT_GrabInput(_THIS, SDL_GrabMode mode);
 
   /* FB driver bootstrap functions */
 
@@ -128,6 +188,8 @@
     device->FreeHWSurface = QT_FreeHWSurface;
     device->SetIcon = NULL;
     device->SetCaption = QT_SetWMCaption;
+    device->IconifyWindow = QT_IconifyWindow;
+    device->GrabInput = QT_GrabInput;
     device->GetWMInfo = NULL;
     device->FreeWMCursor = QT_FreeWMCursor;
     device->CreateWMCursor = QT_CreateWMCursor;
@@ -224,7 +286,7 @@
 
     // For now we hardcode the current depth because anything else
     // might as well be emulated by SDL rather than by Qtopia.
-    
+
     QSize desktop_size = qApp->desktop()->size();
     QT_AddMode(_this, ((vformat->BitsPerPixel+7)/8)-1,
 	       desktop_size.width(), desktop_size.height());
@@ -237,7 +299,17 @@
     /* Fill in some window manager capabilities */
     _this->info.wm_available = 0;
 
-    /* We're done! */
+#ifdef QTOPIA_LOG
+    st_logfp = fopen("/tmp/sdl-qt-debug", "w");
+    if (!st_logfp)
+      st_logfp = stderr;
+#endif
+
+    {
+      QCopEnvelope e("QPE/KeyHelper", "repeater(int)");
+      e << 2;
+    }
+
     return(0);
   }
 
@@ -272,35 +344,241 @@
     return -1;
   }
 
+  static machine_t QT_GetMachine(_THIS)
+  {
+    FILE *fp;
+    machine_t machine = MACHINE_SHARP_SL5000D;
+    char buf[512];
+
+    fp = fopen("/proc/deviceinfo/product", "rb");
+    if (fp) {
+      if (fread(buf, 1, sizeof(buf), fp) > 0) {
+        LOG("QT_GetMachine: /proc/deviceinfo/product is '%s'\n", buf);
+        if (strncmp(buf, "SL-A300", 7) == 0)
+          machine = MACHINE_SHARP_SLA300;
+        else if (strncmp(buf, "SL-5500", 7) == 0)
+          machine = MACHINE_SHARP_SL5500;
+        else if (strncmp(buf, "SL-B500", 7) == 0)
+          machine = MACHINE_SHARP_SLB500;
+        else if (strncmp(buf, "SL-C700", 7) == 0)
+          machine = MACHINE_SHARP_SLC700;
+        else if (strncmp(buf, "SL-C750", 7) == 0)
+          machine = MACHINE_SHARP_SLC750;
+        else if (strncmp(buf, "SL-C760", 7) == 0)
+          machine = MACHINE_SHARP_SLC760;
+        else if (strncmp(buf, "SL-C860", 7) == 0)
+          machine = MACHINE_SHARP_SLC860;
+        else if (strncmp(buf, "SL-6000", 7) == 0)
+          machine = MACHINE_SHARP_SL6000;
+      }
+      fclose(fp);
+    } else {
+      LOG("QT_GetMachine: Couldn't read /proc/deviceinfo/product.\n");
+      LOG(" Now set machine variable to default (SL-5000D)\n");
+    }
+
+    LOG(" detected machine is '%s %s'\n",
+        st_machine_spec[machine].manif, st_machine_spec[machine].name);
+    return machine;
+  }
+
+  static void QT_GetQteServerSpec(_THIS, int *rotation, bool *isQvga)
+  {
+    const char *user;
+    char buf[FILENAME_MAX];
+    FILE *fp;
+    int rot = 0, is_qvga = 0;
+
+    user = getenv("USER");
+    snprintf(buf, sizeof(buf), "/tmp/qtembedded-%s/QtEmbedded-0.spec",
+             user ? user : "root");
+    LOG("QT_GetRotation: Read spec from '%s'\n", buf);
+
+    fp = fopen(buf, "rb");
+    if (fp) {
+      int size;
+      if ((size = fread(buf, 1, sizeof(buf) - 1, fp)) > 0) {
+        buf[size] = '\0';
+        LOG(" spec is '%s'\n", buf);
+        // get rotation value
+        if (strstr(buf, "Rot")) {
+          rot = atoi(strstr(buf, "Rot") + 3);
+          rot /= 90;
+          if (rot < 0 || rot > 3) {
+            rot = 0;
+          }
+        } else
+          rot = 0;
+
+        // get qvga mode in SL-C700
+        if (strstr(buf, "Qvga"))
+          is_qvga = 1;
+      }
+      fclose(fp);
+    }
+
+    LOG(" Rot=%d, Qvga=%d\n", rot, is_qvga);
+
+    if (rotation)
+      *rotation = rot;
+    if (isQvga)
+      *isQvga = is_qvga;
+  }
+
   /* FIXME: check return values and cleanup here */
   SDL_Surface *QT_SetVideoMode(_THIS, SDL_Surface *current,
 			       int width, int height, int bpp, Uint32 flags)
   {
-
     QImage *qimage;
-    QSize desktop_size = qApp->desktop()->size();
+    QSize qteSize = qApp->desktop()->size();
+    QSize fbSize;
+    QSize userSize;
+
+    machine_t machine = QT_GetMachine(_this);
+    machine_spec_t machineSpec = st_machine_spec[machine];
+    int qteRotation, userRotation, sdlRotation;
+    int qteKeyRotation, sdlKeyRotation;
+    bool isQteQvga;
+
+    // qte ¤Ç¤Î²óÅ¾³ÑÅÙ¤ò¼èÆÀ
+    QT_GetQteServerSpec(_this, &qteRotation, &isQteQvga);
+
+    // hack for SL-5500
+    if (machine == MACHINE_SHARP_SL5500)
+      qteRotation = 3;
+
+    // SL-B500 ÍÑ¥Ï¥Ã¥¯(¤È¤ê¤¢¤¨¤º¡¢¤Í)
+    if (machine == MACHINE_SHARP_SLB500)
+      qteRotation = 3;
+#if 0
+    // SL-C750/760 ÍÑ¥Ï¥Ã¥¯(Thanks to ÉÍÃÏ¤µ¤ó)
+    if (machine == MACHINE_SHARP_SLC750 || machine == MACHINE_SHARP_SLC760)
+      qteRotation = (qteRotation + 2) & 3;
+#endif
+    // À¸¥Õ¥ì¡¼¥à¥Ð¥Ã¥Õ¥¡¤Î¥µ¥¤¥º¤òÆÀ¤ë
+    if (qteRotation & 1) {
+      fbSize.setWidth(qteSize.height());
+      fbSize.setHeight(qteSize.width());
+    } else {
+      fbSize = qteSize;
+    }
 
-    
-    current->flags = SDL_FULLSCREEN; // We always run fullscreen.
+    //
+    const char *envRotStr = getenv(SDL_QT_ROTATION_ENV_NAME);
+    userRotation = envRotStr ? atoi(envRotStr) : -1;
+    if ((userRotation >= 0 ? userRotation : qteRotation) & 1) {
+      userSize.setWidth(fbSize.height());
+      userSize.setHeight(fbSize.width());
+    } else {
+      userSize = fbSize;
+    }
 
-    if(width <= desktop_size.width()
-	      && height <= desktop_size.height()) {
-      current->w = desktop_size.width();
-      current->h = desktop_size.height();
-    } else if(width <= desktop_size.height() && height <= desktop_size.width()) {
-      // Landscape mode
-      char * envString = getenv(SDL_QT_ROTATION_ENV_NAME);
-      int envValue = envString ? atoi(envString) : 0;
-      screenRotation = envValue ? SDL_QT_ROTATION_270 : SDL_QT_ROTATION_90;
-      current->h = desktop_size.width();
-      current->w = desktop_size.height();
+    // SL-C700 ¤Î¥¹¥¿¥¤¥ë
+    bool isInputStyle = false;
+    if (machine == MACHINE_SHARP_SLC700 ||
+        machine == MACHINE_SHARP_SLC750 ||
+        machine == MACHINE_SHARP_SLC760 ||
+        machine == MACHINE_SHARP_SLC860 ||
+        machine == MACHINE_SHARP_SL6000) {
+      int status = system("/home/QtPalmtop/bin/chkhinge");
+      if (WEXITSTATUS(status) != 2)
+        isInputStyle = true;
+      LOG("QT_SetVideoMode: SL-C700 Style is %s\n",
+          isInputStyle ? "Input style" : "View style");
+    }
+
+    // ¤Þ¤º¡¢Í×µá¤µ¤ì¤¿¥¦¥£¥ó¥É¥¦¥µ¥¤¥º¤¬¥æ¡¼¥¶¤ÎË¾¤à²óÅ¾³ÑÅÙ¤Î¥¹¥¯¥ê¡¼¥ó¤Ë
+    // ¼ý¤Þ¤ë¤Î¤«¤ò¥Á¥§¥Ã¥¯¡£
+    if (width <= userSize.width() && height <= userSize.height()) {
+      // ´Ä¶­ÊÑ¿ô¤Ç²óÅ¾³ÑÅÙ¤¬»ØÄê¤µ¤ì¤Æ¤¤¤ì¤Ð¡¢¤½¤ì¤òºÇÍ¥Àè¤¹¤ë
+      if (userRotation >= 0)
+        sdlRotation = userRotation;
+      else {
+        // ¤Ç¡¢¤½¤Î»ØÄê¤¬Ìµ¤¤¤Î¤Ç¤¢¤ì¤Ð qte ¤Î²óÅ¾³ÑÅÙ¤Ë¹ç¤ï¤»¤ë¤À¤±
+        // ¤Ê¤ó¤À¤±¤É¡¢SL-C700 ¤Ç¤Ï¤Á¤ç¤¤Ê£»¨¡£
+        if ((machine == MACHINE_SHARP_SLC700 ||
+             machine == MACHINE_SHARP_SLC750 ||
+             machine == MACHINE_SHARP_SLC760 ||
+             machine == MACHINE_SHARP_SLC860 ||
+             machine == MACHINE_SHARP_SL6000) &&
+            fbSize.width() == 320 && fbSize.height() == 240) {
+          if (isInputStyle)
+            sdlRotation = 2;
+          else
+            sdlRotation = qteRotation;
+        } else {
+          sdlRotation = qteRotation;
+        }
+      }
+    } else if (width <= fbSize.width() && height <= fbSize.height()) {
+      sdlRotation = 0;
+      if ((machine == MACHINE_SHARP_SLC700 ||
+           machine == MACHINE_SHARP_SLC750 ||
+           machine == MACHINE_SHARP_SLC760 ||
+           machine == MACHINE_SHARP_SLC860 ||
+           machine == MACHINE_SHARP_SL6000) &&
+          fbSize.width() == 320 && fbSize.height() == 240
+          && isInputStyle)
+        sdlRotation = 2;
+    } else if (width <= fbSize.height() && height <= fbSize.width()) {
+      sdlRotation = 1;
     } else {
       SDL_SetError("Unsupported resolution, %dx%d\n", width, height);
+      return NULL;
     }
+
+    if (getenv(SDL_QT_INVERT_ROTATION_ENV_NAME) != NULL) {
+      sdlRotation = (sdlRotation + 2) & 3;
+    }
+#if 0
+    if (machine == MACHINE_SHARP_SLC750 || machine == MACHINE_SHARP_SLC760)
+      sdlRotation = (sdlRotation + 2) & 3;
+#endif
+    LOG("QT_SetVideoMode: argSize=%dx%d\n", width, height);
+    LOG("QT_SetVideoMode: qteSize=%dx%d\n",
+        qteSize.width(), qteSize.height());
+    LOG("QT_SetVideoMode: fbSize=%dx%d\n",
+        fbSize.width(), fbSize.height());
+    LOG("QT_SetVideoMode: qteRotation=%d\n", qteRotation);
+    LOG("QT_SetVideoMode: userRotation=%d\n", userRotation);
+    LOG("QT_SetVideoMode: sdlRotation=%d\n", sdlRotation);
+
+    current->flags = 0;//SDL_FULLSCREEN; // We always run fullscreen.
+    current->w = width;
+    current->h = height;
+    SDL_Win->setScreenRotation(sdlRotation, qteRotation);
+    SDL_Win->setFBSize(fbSize);
+
+    if (machine == MACHINE_SHARP_SLA300)
+      SDL_Win->setSLA300InputFix(true);
+
+    // keyboard rotation
+    qteKeyRotation = qteRotation;
+//     fprintf(stderr, "%d\n", (machine == MACHINE_SHARP_SLC700));
+//     fprintf(stderr, "%d\n", isQteQvga);
+    if (isQteQvga && (machine == MACHINE_SHARP_SLC700 ||
+                      machine == MACHINE_SHARP_SLC750 ||
+                      machine == MACHINE_SHARP_SLC760 ||
+                      machine == MACHINE_SHARP_SLC860 ||
+                      machine == MACHINE_SHARP_SL6000))
+      qteKeyRotation = 3;
+    else if (machine == MACHINE_SHARP_SLB500)
+      qteKeyRotation = 3;
+
+    sdlKeyRotation = sdlRotation;
+
+    SDL_Win->setKeyRotation(sdlKeyRotation, qteKeyRotation);
+
+    LOG("QT_SetVideoMode: qteKeyRotation=%d\n", qteKeyRotation);
+    LOG("QT_SetVideoMode: sdlKeyRotation=%d\n", sdlKeyRotation);
+
+//     if (isSlc700 && isQvga)
+//       SDL_Win->setSLC700InputFix(true);
+
     if ( flags & SDL_OPENGL ) {
       SDL_SetError("OpenGL not supported");
       return(NULL);
-    } 
+    }
     /* Create the QImage framebuffer */
     qimage = new QImage(current->w, current->h, bpp);
     if (qimage->isNull()) {
@@ -313,6 +591,9 @@
     SDL_Win->setImage(qimage);
     _this->UpdateRects = QT_NormalUpdate;
     SDL_Win->setFullscreen(true);
+
+    //     fprintf(stderr,"QT_SetVideoMode() qImage:%dx%d %d\n",
+    // 			qimage->width(), qimage->height(), qimage->bytesPerLine());
     /* We're done */
     return(current);
   }
@@ -355,14 +636,14 @@
 
   static void QT_NormalUpdate(_THIS, int numrects, SDL_Rect *rects)
   {
-    int i;
-    SDL_Win->lockScreen(); 
-    for ( i=0; i<numrects; ++i ) {
-      QRect rect(rects[i].x, rects[i].y,
-		 rects[i].w, rects[i].h);
-      SDL_Win->repaintRect(rect);
+    if(SDL_Win->lockScreen()) {
+      for(int i=0; i<numrects; ++i ) {
+	    QRect rect(rects[i].x, rects[i].y,
+                  rects[i].w, rects[i].h);
+       SDL_Win->repaintRect(rect);
+      }
+      SDL_Win->unlockScreen();
     }
-    SDL_Win->unlockScreen(); 
   }
   /* Is the system palette settable? */
   int QT_SetColors(_THIS, int firstcolor, int ncolors, SDL_Color *colors)
@@ -380,6 +661,30 @@
     //    delete SDL_Win; 
     //    SDL_Win = 0;
     _this->screen->pixels = NULL;
+    QT_GrabInput(_this, SDL_GRAB_OFF);
+
+    {
+      QCopEnvelope e("QPE/KeyHelper", "repeater(int)");
+      e << 1;
+    }
+  }
+
+  static int QT_IconifyWindow(_THIS) {
+    SDL_Win->hide();
+    
+    return true;
+  }
+
+  static SDL_GrabMode QT_GrabInput(_THIS, SDL_GrabMode mode) {
+    if(mode == SDL_GRAB_OFF) {
+      QPEApplication::grabKeyboard();
+      qApp->processEvents();
+      QPEApplication::ungrabKeyboard();
+    } else {
+      QPEApplication::grabKeyboard();
+    }
+    qApp->processEvents();
+    return mode;
   }
 
 }; /* Extern C */
